namespace MyWinForms.Components

open System.ComponentModel
open System.Windows.Forms
open System.Windows.Forms.VisualStyles
open System.Drawing

// <remarks>
// CheckedState is an enum of all allowable nodes states
// </remarks>
type CheckedState  =
    | UnInitialised 
    | UnChecked
    | Checked
    | Mixed 
    static member index = function
        | UnInitialised -> -1
        | UnChecked -> 0
        | Checked -> 1
        | Mixed -> 2
    static member checkBoxState = function
        | UnInitialised -> None
        | UnChecked -> Some CheckBoxState.UncheckedNormal
        | Checked -> Some CheckBoxState.CheckedNormal
        | Mixed -> Some CheckBoxState.MixedNormal

    static member values = [ UnInitialised; UnChecked; Checked; Mixed ]
    
// <summary>
// A Tri-State TreeView designed for on-demand populating of the tree
// </summary>
// <remarks>
// 'Mixed' nodes retain their checked state, meaning they can be checked or unchecked according to their current state
// Tree can be navigated by keyboard (cursor keys & space)
// No need to do anything special in calling code
// </remarks>
type TriStateCheckTreeView() = 
    inherit TreeView()

    // <remarks>
    // IgnoreClickAction is used to ingore messages generated by setting the node.Checked flag in code
    // Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c> otherwise the Checked state will be lost
    // </remarks>
    let mutable ignoreClickAction = 0
    // <remarks>

    let stateImageChangedEvent = new Event<_>()

    let (<==) x y = TriStateCheckTreeView.setStateImageIndex(x,y)

    [<CLIEvent>]
    member x.StateImageIndexChanged = stateImageChangedEvent.Publish

    static member setStateImageIndex (node:TreeNode, value) = 
        (node.TreeView :?> TriStateCheckTreeView).SetStateImageIndex(node,value)

    member private x.SetStateImageIndex(node:TreeNode, value) = 
        //if node.StateImageIndex <> value then
            node.StateImageIndex <- value
            stateImageChangedEvent.Trigger (node,value)

    // Called once before window displayed.  Disables default Checkbox functionality and ensures all nodes display an 'unchecked' image.
    override x.OnCreateControl() =
        base.OnCreateControl()


        x.StateImageList <- new ImageList()        
        for checkBoxState in CheckedState.values |> List.choose CheckedState.checkBoxState do
            let bmp = new Bitmap(16, 16)
            let chkGraphics = Graphics.FromImage(bmp)
            CheckBoxRenderer.DrawCheckBox(chkGraphics, Point(0, 1), checkBoxState)
            x.StateImageList.Images.Add bmp
            //bmp.Save (sprintf "xxx_%A.bmp" checkBoxState)

        x.CheckBoxes <- false; // Disable default CheckBox functionality if it's been enabled

        // Give every node an initial 'unchecked' image
        ignoreClickAction  <- ignoreClickAction + 1 // we're making changes to the tree, ignore any other change requests
        x.UpdateChildState(x.Nodes, CheckedState.index CheckedState.UnChecked, false, true)
        ignoreClickAction  <- ignoreClickAction - 1


    // Helper function to replace child state with that of the parent
    member x.UpdateChildState( nodes : TreeNodeCollection, stateImageIndex, isChecked, changeUninitialisedNodesOnly) =
        for tnChild in nodes do
            if not changeUninitialisedNodesOnly || tnChild.StateImageIndex = -1 then
                tnChild <== stateImageIndex
                tnChild.Checked <- isChecked  // override 'checked' state of child with that of parent
                if tnChild.Nodes.Count > 0 then
                    x.UpdateChildState(tnChild.Nodes, stateImageIndex, isChecked, changeUninitialisedNodesOnly)

    // Helper function to notify parent it may need to use 'mixed' state
    member x.UpdateParentState(tn:TreeNode) =
        
        // Node needs to check all of it's children to see if any of them are ticked or mixed
        if tn = null then () else
        let origStateImageIndex = tn.StateImageIndex;
        let mutable unCheckedNodes = 0
        let mutable checkedNodes = 0
        let mutable mixedNodes = 0
        
        // The parent needs to know how many of it's children are Checked or Mixed
        for tnChild in tn.Nodes do
            if tnChild.StateImageIndex = CheckedState.index Checked then
                checkedNodes <- checkedNodes + 1
            elif tnChild.StateImageIndex = CheckedState.index  Mixed then
                mixedNodes <- mixedNodes + 1
            else unCheckedNodes <- unCheckedNodes + 1
            

        // Determine the parent's new Image State         
        let stt = 
            if mixedNodes > 0 then
                // at least one child is mixed, so parent must be mixed
                Mixed
            elif checkedNodes > 0 && unCheckedNodes = 0 then
                if tn.Checked then Checked else Mixed 
            elif checkedNodes > 0 then
                // some children are checked, the rest are unchecked
                Mixed
            else
                // all children are unchecked
                if tn.Checked then Mixed else UnChecked  
        tn <== CheckedState.index stt
        if origStateImageIndex <> tn.StateImageIndex && tn.Parent <> null then
            // Parent's state has changed, notify the parent's parent
            x.UpdateParentState(tn.Parent)

    // Called after a node is checked.  Forces all children to inherit current state, and notifies parents they may need to become 'mixed'
    override x.OnAfterCheck(e) =
        base.OnAfterCheck(e)
        if ignoreClickAction > 0 then () else
            ignoreClickAction <- ignoreClickAction + 1  // we're making changes to the tree, ignore any other change requests
            // the checked state has already been changed, we just need to update the state index
            // node is either ticked or unticked.  ignore mixed state, as the node is still only ticked or unticked regardless of state of children
            let tn = e.Node
            let index = CheckedState.index (if tn.Checked then Checked else UnChecked )
            tn <== index
            // force all children to inherit the same state as the current node
            x.UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, false)

            // populate state up the tree, possibly resulting in parents with mixed state
            x.UpdateParentState(e.Node.Parent)
            ignoreClickAction <- ignoreClickAction - 1

    // Called after a node is expanded.  Ensures any new nodes display an 'unchecked' image
    override x.OnAfterExpand(e) =
        // If any child node is new, give it the same check state as the current node
        // So if current node is ticked, child nodes will also be ticked
        base.OnAfterExpand(e)
        
        ignoreClickAction <- ignoreClickAction + 1 // we're making changes to the tree, ignore any other change requests
        x.UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true)
        ignoreClickAction <- ignoreClickAction - 1

    // Called on keypress.  Used to change node state when Space key is pressed
    // Invokes OnAfterCheck to do the real work
    override x.OnKeyDown(e) =
        base.OnKeyDown(e);
        // is the keypress a space?  If not, discard it
        if e.KeyCode = Keys.Space then
            // toggle the node's checked status.  This will then fire OnAfterCheck
            x.SelectedNode.Checked <- not x.SelectedNode.Checked

    // Called when node is clicked by the mouse.  Does nothing unless the image was clicked
    // Invokes OnAfterCheck to do the real work
    override x.OnNodeMouseClick(e) =     
        base.OnNodeMouseClick(e)

        // is the click on the checkbox?  If not, discard it
        let info = x.HitTest(e.X, e.Y)
        if info = null || info.Location <> TreeViewHitTestLocations.StateImage then () else
            // toggle the node's checked status.  This will then fire OnAfterCheck
            let tn = e.Node
            tn.Checked <- not tn.Checked
